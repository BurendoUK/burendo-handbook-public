---
title: Build Phase - Refinement, Implementation, and Deployment
---
# **Build Phase: Refinement, Implementation, and Deployment**

## **Overview**
The **Build Phase** is where designs and plans are turned into **working software** that delivers value to users and the business. This is an **iterative, continuous process** that moves seamlessly from backlog refinement through development, testing, and deployment into production.

Our approach to Build is guided by:  
* **Continuous Flow and Incremental Delivery** – Work progresses iteratively, ensuring value is delivered **frequently and predictably**.  
* **Collaboration and Feedback Loops** – Teams work closely with stakeholders to **validate work early and often**.  
* **Technical and Operational Excellence** – Code quality, automation, and DevOps best practices ensure **robust and maintainable software**.  

### **Inputs and Outputs**
- **Inputs:** Prioritised backlog items, epics, designs, technical spikes, validated requirements.  
- **Outputs:** **Production-ready software**, working in a **real environment**, delivering **business value**.  

## **Choosing the Right Agile Approach: Iterations vs. Continuous Flow**
Different teams and customers have different levels of **comfort and experience with agile delivery**. The **choice between fixed-length iterations and continuous flow** should be based on **team maturity, customer expectations, and delivery context**.

### **1. Fixed-Length Iterations (Scrum-Style Timeboxes)**
* Provide a **clear structure and cadence**, making planning and tracking easier.  
* Help **teams new to agile** establish **rhythms, discipline, and estimation habits**.  
* Give **customers predictability**, allowing them to see what features the team **aims to deliver** in each iteration.  
* Encourage **commitment and focus**, ensuring work is **well-scoped and timeboxed**.  
* May introduce **some rigidity** if not carefully managed.  

### **2. Continuous Flow (Kanban-Style)**
* Works best for **mature, experienced teams** who can **self-manage priorities dynamically**.  
* Reduces **batching and delays**, allowing work to progress as soon as it is ready.  
* Enables **greater responsiveness** to change, without needing to wait for an iteration boundary.  
* Requires **strong backlog discipline** and **clear prioritisation**, or teams risk losing focus.  
* Customers used to traditional delivery may feel they lack **predictability and control**.  

### **3. Choosing the Right Approach**
- **If you have forming teams or customers transitioning from traditional waterfall appraoches** then start with fixed-length iterations for structure and predictability.  
- **If you have experienced, high-autonomy teams** Then a lean, Kanban-style approach may work best.  
- **You can always consider a hybrid approach**. Some teams use fixed iterations for planning, but work in a continuous flow within them.  

## **Working in Iterations with Continuous Flow**
Regardless of the chosen approach, agile teams:  
- Work in **small, iterative cycles** to deliver value frequently.  
- Maintain a **prioritised backlog**, ensuring that the most important work is tackled first.  
- Use **feedback loops** to refine and adapt delivery based on real-world learnings.  

### **1. Maintaining a Steady Cadence**
- Work is planned and delivered **incrementally**, ensuring a **sustainable pace**.  
- Agile techniques from **Kanban, Scrum, and Extreme Programming** help maintain a **consistent and efficient delivery flow**.  

### **2. Refinement: Keeping a Healthy Backlog**
- Backlog refinement ensures **items are well-defined and ready for implementation**.
- Teams hold **regular refinement sessions** (recommended **once or twice per week**) to:
  - Clarify business and technical requirements.
  - Identify and mitigate risks early.
  - Ensure work remains **focused, valuable, and achievable**.
- To balance **upfront planning vs. just-in-time** elaboration:
  - Items are **refined just before implementation** to keep work relevant.  
  - A small **buffer of ready-to-go items** prevents blockers.  

### **3. Prioritisation and Work Selection**
- Priorities are **reviewed daily**, ensuring that teams always focus on **the highest-value work**.  
- Items are **pulled from the backlog as team members become available**—rather than pre-assigning work for an entire iteration.  
- Effective delivery flow is measured using **lead time and cycle time**, ensuring work progresses at an optimal pace.  

## **Implementation: Building High-Quality Software**
### **1. Effective Collaboration and Communication**
- **Daily stand-ups** keep the team aligned, surfacing blockers and ensuring work progresses smoothly.  
- Teams operate with **cross-functional collaboration**, with developers, testers, designers, and stakeholders **working together** rather than in silos.  

### **2. Delivering Incrementally**
- Work is broken down into **small, valuable increments**, ensuring that software can be **delivered and tested continuously**.
- Features are **integrated frequently** to prevent large, high-risk deployments.
- Testing is embedded throughout development, with a focus on **automated and exploratory testing**.

### **3. Quality and Technical Excellence**
- **Pair programming, code reviews, and automated testing** help maintain a high standard of quality.  
- Teams adhere to **Extreme Programming (XP) principles**, focusing on:
  - **Simple design**
  - **Continuous integration**
  - **Frequent feedback loops**
  - **Collective code ownership**  


## **Deployment: Getting Software Into Production**
### **1. Continuous Deployment and Release Strategies**
- Software is deployed **frequently and safely** using techniques like:
  - **Feature flags** – Allowing new features to be enabled or disabled dynamically.  
  - **Blue-green deployments** – Minimising downtime and risk.  
  - **Canary releases** – Rolling out features to a small percentage of users before full release.  

### **2. Ensuring Operational Readiness**
- **Monitoring and observability** are embedded into the process to ensure production software is:
  - **Reliable and performant**
  - **Easily debuggable**
  - **Proactively monitored for issues**  
- Operations and engineering teams work together to **ensure a smooth transition to live environments**.  

### **3. Learning from Production**
- Regular **post-release analysis** ensures teams learn from deployments.  
- Monitoring data and user feedback inform **future prioritisation and backlog refinement**.  


## **Iteration Reviews: Ensuring Continuous Improvement**
- Every **two weeks (or as appropriate)**, teams hold an **iteration review** to:
  - Demonstrate completed work to stakeholders.
  - Gather feedback on business impact and usability.
  - Surface **risks, dependencies, and new insights**.
- Reviews should be **collaborative discussions**, not just presentations.  
- Outcomes should drive **adjustments to the roadmap, backlog, and priorities**.  


## **Key Takeaways: The Build Phase in Action**
* **Agile approach should be tailored** – Fixed-length iterations provide structure for forming teams, while continuous flow works best for experienced teams.  
* Work progresses iteratively, either in fixed-length iterations or continuous flow, depending on what best suits the team and customer.
* **Refinement keeps a healthy backlog**, ensuring teams always have valuable, well-defined work to tackle.  
* **Implementation follows high-quality engineering practices**, ensuring **robust, scalable, and maintainable software**.  
* **Deployment is fast, safe, and reliable**, ensuring that users get value as soon as possible.  
* **Reviews and retrospectives** help teams adapt, improve, and remain aligned to business goals.  
